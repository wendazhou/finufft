"""Utility code to generate polynomial approximation of the given kernel.
"""

from __future__ import annotations

import dataclasses
import functools
import os
import sys
from typing import Iterable, Tuple

import numpy as np

def kernel(z, beta):
    return np.exp(beta * np.sqrt(1 - z**2))

def _make_grid(n):
    return 2 * (np.arange(n) + 0.5) / n - 1

def make_colocation_points(num_points: int) -> np.ndarray:
    grid = _make_grid(num_points)
    return np.concatenate((grid - 1j, 1 + grid * 1j, grid + 1j, -1 + grid * 1j))

def evaluate_function(fn, x: np.ndarray, width: int):
    grid = _make_grid(width)
    return fn(np.add.outer(x / width, grid))

def fit_polynomial(fn, degree: int, width: int, num_colocation_points: int=None) -> np.ndarray:
    """Fits a piecewise polynomial to the given function supported on [-1, 1] at equispaced points
    on [-1, 1] where the number of points is given by width.

    Note that the function must be able to be evaluated on the complex plane.

    Parameters
    ----------
    fn : callable
        Function to fit.
    degree : int
        Degree of the polynomial to fit.
    width : int
        Number of grid samples at which to evaluate the fit
    num_colocation_points : int, optional
        If not `None`, the number of points on each side of the box to evaluate
        for the fit. Otherwise, uses 16 times the degree.

    Returns
    -------
    np.ndarray
        An array of shape [degree + 1, width] containing the coefficients of the polynomial
        at each location.
    """
    if num_colocation_points is None:
        num_colocation_points = 16 * degree

    x = make_colocation_points(num_colocation_points)
    V = np.vander(x, degree + 1, increasing=True)
    R = evaluate_function(fn, x, width)
    return np.real(np.linalg.lstsq(V, R, rcond=None)[0])


def reference_multi(x: np.ndarray, beta: float, width: int):
    """Evaluates the reference function at all points corresponding to the fit with the given width.

    This function is a utility to directly model the fitted polynomial.
    Its output is comparable to calling `np.polyval` on the fitted coefficients.

    Parameters
    ----------
    x : np.ndarray
        Array of values at which to evaluate the reference function.
        Each value should be in the range [-1, 1], and represents the fractional position
        of the evaluation point within the segment defined by cutting the range [-1, 1] into
        `width` different parts.
    beta : float
        The beta parameter of the kernel.
    width : int
        The number of segments into which to cut the range [-1, 1].

    Returns
    -------
    np.ndarray
        Array of values corresponding to the reference function evaluated in each segment.
        Has shape [B, width], where B denotes the shape of `x`.
    """
    centers = _make_grid(width)
    x = x / width
    x = np.add.outer(x, centers)
    return kernel(x, beta)


def standard_configuration():
    """Standard configurations (for upsampling factor of 2) used in finufft.
    """
    widths = np.arange(2, 17)
    beta_over_width = np.array([2.20, 2.26, 2.38, 2.30])
    beta = beta_over_width[np.clip(widths - 2, a_min=None, a_max=len(beta_over_width) - 1)] * widths
    degrees = widths + 2 + (widths <= 8);  # between 2-3 more degree than w
    return list(zip(degrees, beta, widths))

def generic_configuration(upsample_factor=2):
    """Generic configuration (for upsampling factor other than 2) used in finufft.
    """
    widths = np.arange(2, 17)
    gamma=0.97
    betaoverws = gamma*np.pi*(1-1/(2*upsample_factor))
    beta = betaoverws * widths
    degrees = widths + 1 + (widths<=8)
    return list(zip(degrees, beta, widths))


def compute_coefficients(configurations: Iterable[Tuple[int, float, int]]):
    """Compute coefficients for the given configurations."""
    for degree, beta, width in configurations:
        coefficients = fit_polynomial(functools.partial(kernel, beta=beta), degree, width)
        yield (degree, beta, width), coefficients


def write_coefficients_source(coefficients: Iterable[Tuple[Tuple[int, float, int], np.ndarray]], fp=sys.stdout):
    configs = []

    print("// Data generated by make_kernel_weights.py - do not directly modify!\n", file=fp)
    print('#include "precomputed_poly_kernel_data.h"\n', file=fp)
    print("namespace finufft { namespace detail {", file=fp)

    for i, (config, coeffs) in enumerate(coefficients):
        configs.append(config)
        print(f"static const double coefficients_{i}[] = {{ {','.join(str(x) for x in coeffs.flatten().tolist())} }};", file=fp)

    print("static const precomputed_poly_kernel_data poly_kernel_index[] = {", file=fp)
    for i, config in enumerate(configs):
        print(f"{{ {config[0]}, {int(1000 * config[1])}, {config[2]}, coefficients_{i} }},", file=fp)
    print("};", file=fp)
    print("const tcb::span<const precomputed_poly_kernel_data> precomputed_poly_kernel_data_table = tcb::span<const precomputed_poly_kernel_data>(poly_kernel_index);", file=fp)
    print("} } // namespace finufft::detail", file=fp)


def evaluate_difference(degree: int, beta: float, width: int):
    """Evaluate difference between reference and fitted polynomial with given parameters.

    Parameters
    ----------
    degree : int
        Degree of the polynomial to fit.
    beta : float
        The beta parameter of the kernel.
    width : int
        The number of segments into which to cut the range [-1, 1].
    """
    coefficients = fit_polynomial(functools.partial(kernel, beta=beta), degree, width)
    # np.polyval requires the coefficients to be in reverse order
    coefficients = coefficients[::-1]

    x = np.linspace(-1, 1, num=100)
    reference = reference_multi(x, beta, width)
    fitted = np.stack([np.polyval(coefficients[:, i], x) for i in range(width)], axis=1)

    return np.max(np.abs(reference - fitted), axis=0)


def main():
    configs = standard_configuration() + generic_configuration(1.25)
    coefficients = compute_coefficients(configs)

    root = os.path.dirname(os.path.abspath(__file__))

    with open(os.path.join(root, "../src/precomputed_poly_kernel_data.cpp"), "w") as fp:
        write_coefficients_source(coefficients, fp)

if __name__ == '__main__':
    main()